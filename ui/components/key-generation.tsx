"use client";

import { useState, useMemo, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { findPrimesInRange, generateKeyPair, isValidPaillierPair, type PaillierKeyPair } from "@/lib/paillier";
import { KeyRound, Lock, Unlock, ChevronDown } from "lucide-react";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";

interface KeyGenerationProps {
  onKeyGenerated: (keyPair: PaillierKeyPair) => void;
  keyPair: PaillierKeyPair | null;
}

export function KeyGeneration({ onKeyGenerated, keyPair }: KeyGenerationProps) {
  const [minRange, setMinRange] = useState(2);
  const [maxRange, setMaxRange] = useState(15);
  const [selectedP, setSelectedP] = useState<string>("");
  const [selectedQ, setSelectedQ] = useState<string>("");
  const [error, setError] = useState<string>("");
  const hasAutoGenerated = useRef(false);

  const primes = useMemo(() => {
    return findPrimesInRange(minRange, maxRange);
  }, [minRange, maxRange]);

  // Filter q options to only show primes that form a valid Paillier pair with selected p
  const validQPrimes = useMemo(() => {
    if (!selectedP) return primes;
    const p = BigInt(selectedP);
    return primes.filter((q) => q !== p && isValidPaillierPair(p, q));
  }, [primes, selectedP]);

  // Filter p options to only show primes that form a valid Paillier pair with selected q
  const validPPrimes = useMemo(() => {
    if (!selectedQ) return primes;
    const q = BigInt(selectedQ);
    return primes.filter((p) => p !== q && isValidPaillierPair(p, q));
  }, [primes, selectedQ]);

  // Auto-clear q if it becomes invalid after p changes
  useEffect(() => {
    if (selectedQ && selectedP) {
      const isStillValid = validQPrimes.some((q) => q.toString() === selectedQ);
      if (!isStillValid) {
        setSelectedQ("");
      }
    }
  }, [selectedP, validQPrimes, selectedQ]);

  // Auto-clear p if it becomes invalid after q changes
  useEffect(() => {
    if (selectedP && selectedQ) {
      const isStillValid = validPPrimes.some((p) => p.toString() === selectedP);
      if (!isStillValid) {
        setSelectedP("");
      }
    }
  }, [selectedQ, validPPrimes, selectedP]);

  // Auto-generate keys on first mount with a valid random p and q
  useEffect(() => {
    if (hasAutoGenerated.current) return;
    if (primes.length < 2) return;

    hasAutoGenerated.current = true;

    // Find a valid pair from all possible combinations (shuffled for randomness)
    const shuffled = [...primes].sort(() => Math.random() - 0.5);
    let foundPair = false;

    for (let i = 0; i < shuffled.length && !foundPair; i++) {
      for (let j = 0; j < shuffled.length && !foundPair; j++) {
        if (i === j) continue;
        const p = shuffled[i];
        const q = shuffled[j];
        if (isValidPaillierPair(p, q)) {
          setSelectedP(p.toString());
          setSelectedQ(q.toString());
          try {
            const keys = generateKeyPair(p, q);
            onKeyGenerated(keys);
            foundPair = true;
          } catch {
            // Try next pair
          }
        }
      }
    }
  }, [primes, onKeyGenerated]);

  const handleGenerateKeys = () => {
    setError("");
    
    if (!selectedP || !selectedQ) {
      setError("Please select both p and q");
      return;
    }

    const p = BigInt(selectedP);
    const q = BigInt(selectedQ);

    if (p === q) {
      setError("p and q must be different primes");
      return;
    }

    try {
      const keys = generateKeyPair(p, q);
      onKeyGenerated(keys);
    } catch (e) {
      setError(e instanceof Error ? e.message : "Error generating keys. Please try different primes.");
    }
  };

  const formatBigInt = (n: bigint): string => {
    const str = n.toString();
    if (str.length > 20) {
      return str.slice(0, 10) + "..." + str.slice(-10);
    }
    return str;
  };

  return (
    <Card className="border-border bg-card">
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-foreground">
          <KeyRound className="h-5 w-5 text-primary" />
          Key Generation
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Range Selection */}
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="minRange" className="text-muted-foreground">Min Range</Label>
            <Input
              id="minRange"
              type="number"
              value={minRange}
              onChange={(e) => setMinRange(parseInt(e.target.value) || 2)}
              min={2}
              className="bg-secondary border-border text-foreground"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="maxRange" className="text-muted-foreground">Max Range</Label>
            <Input
              id="maxRange"
              type="number"
              value={maxRange}
              onChange={(e) => setMaxRange(parseInt(e.target.value) || 100)}
              min={minRange + 1}
              className="bg-secondary border-border text-foreground"
            />
          </div>
        </div>

        <p className="text-sm text-muted-foreground">
          Found {primes.length} primes in range [{minRange}, {maxRange}]
        </p>

        {/* Prime Selection */}
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label className="text-muted-foreground">Select p</Label>
            <Select value={selectedP} onValueChange={setSelectedP}>
              <SelectTrigger className="bg-secondary border-border text-foreground">
                <SelectValue placeholder="Choose prime p" />
              </SelectTrigger>
              <SelectContent className="bg-card border-border">
                {validPPrimes.map((prime) => (
                  <SelectItem
                    key={prime.toString()}
                    value={prime.toString()}
                    className="text-foreground hover:bg-secondary"
                  >
                    {prime.toString()}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-2">
            <Label className="text-muted-foreground">Select q</Label>
            <Select value={selectedQ} onValueChange={setSelectedQ}>
              <SelectTrigger className="bg-secondary border-border text-foreground">
                <SelectValue placeholder="Choose prime q" />
              </SelectTrigger>
              <SelectContent className="bg-card border-border">
                {validQPrimes.map((prime) => (
                  <SelectItem
                    key={prime.toString()}
                    value={prime.toString()}
                    className="text-foreground hover:bg-secondary"
                  >
                    {prime.toString()}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>

        {error && <p className="text-sm text-destructive">{error}</p>}

        <Button
          onClick={handleGenerateKeys}
          className="w-full bg-primary hover:bg-primary/90 text-primary-foreground"
          disabled={!selectedP || !selectedQ}
        >
          Generate Key Pair
        </Button>

        {/* Display Keys */}
        {keyPair && (
          <div className="space-y-4 pt-4 border-t border-border">
            {/* Public Key */}
            <div className="space-y-3">
              <div className="flex items-center gap-2 text-primary">
                <Lock className="h-4 w-4" />
                <span className="font-medium">Public Key (n, g)</span>
              </div>
              <div className="bg-secondary rounded-lg p-4 font-mono text-sm">
                {/* Compact summary */}
                <div className="flex flex-wrap gap-x-6 gap-y-1">
                  <p className="text-muted-foreground">
                    n = <span className="text-primary font-semibold">{formatBigInt(keyPair.publicKey.n)}</span>
                  </p>
                  <p className="text-muted-foreground">
                    g = <span className="text-primary font-semibold">{formatBigInt(keyPair.publicKey.g)}</span>
                  </p>
                  <p className="text-muted-foreground">
                    n² = <span className="text-primary font-semibold">{formatBigInt(keyPair.publicKey.nSquared)}</span>
                  </p>
                </div>

                {/* Expandable derivation */}
                <Collapsible>
                  <CollapsibleTrigger className="flex items-center gap-1 text-xs text-muted-foreground hover:text-primary transition-colors mt-3 group cursor-pointer">
                    <ChevronDown className="h-3 w-3 transition-transform group-data-[state=open]:rotate-180" />
                    Show derivation
                  </CollapsibleTrigger>
                  <CollapsibleContent>
                    <div className="mt-3 pt-3 border-t border-border/50 space-y-2">
                      <p className="text-muted-foreground">
                        n = p × q = {keyPair.steps.p.toString()} × {keyPair.steps.q.toString()} ={" "}
                        <span className="text-primary font-semibold">{formatBigInt(keyPair.publicKey.n)}</span>
                      </p>
                      <p className="text-muted-foreground">
                        g = n + 1 = {formatBigInt(keyPair.publicKey.n)} + 1 ={" "}
                        <span className="text-primary font-semibold">{formatBigInt(keyPair.publicKey.g)}</span>
                      </p>
                      <p className="text-muted-foreground">
                        n² = {formatBigInt(keyPair.publicKey.n)} × {formatBigInt(keyPair.publicKey.n)} ={" "}
                        <span className="text-primary font-semibold">{formatBigInt(keyPair.publicKey.nSquared)}</span>
                      </p>
                    </div>
                  </CollapsibleContent>
                </Collapsible>
              </div>
            </div>

            {/* Private Key */}
            <div className="space-y-3">
              <div className="flex items-center gap-2 text-primary">
                <Unlock className="h-4 w-4" />
                <span className="font-medium">Private Key (λ, μ)</span>
              </div>
              <div className="bg-secondary rounded-lg p-4 font-mono text-sm">
                {/* Compact summary */}
                <div className="flex flex-wrap gap-x-6 gap-y-1">
                  <p className="text-muted-foreground">
                    λ = <span className="text-primary font-semibold">{formatBigInt(keyPair.privateKey.lambda)}</span>
                  </p>
                  <p className="text-muted-foreground">
                    μ = <span className="text-primary font-semibold">{formatBigInt(keyPair.privateKey.mu)}</span>
                  </p>
                </div>

                {/* Expandable derivation */}
                <Collapsible>
                  <CollapsibleTrigger className="flex items-center gap-1 text-xs text-muted-foreground hover:text-primary transition-colors mt-3 group cursor-pointer">
                    <ChevronDown className="h-3 w-3 transition-transform group-data-[state=open]:rotate-180" />
                    Show derivation
                  </CollapsibleTrigger>
                  <CollapsibleContent>
                    <div className="mt-3 pt-3 border-t border-border/50 space-y-3">
                      <div className="space-y-1">
                        <p className="text-muted-foreground text-xs">
                          λ = lcm(p-1, q-1)
                        </p>
                        <p className="text-muted-foreground">
                          λ = lcm({keyPair.steps.pMinus1.toString()}, {keyPair.steps.qMinus1.toString()}) ={" "}
                          <span className="text-primary font-semibold">{formatBigInt(keyPair.privateKey.lambda)}</span>
                        </p>
                      </div>
                      <div className="space-y-1">
                        <p className="text-muted-foreground text-xs">
                          μ = L(g<sup>λ</sup> mod n²)<sup>-1</sup> mod n
                        </p>
                        <p className="text-muted-foreground">
                          g<sup>λ</sup> mod n² = {formatBigInt(keyPair.publicKey.g)}<sup>{formatBigInt(keyPair.privateKey.lambda)}</sup> mod {formatBigInt(keyPair.publicKey.nSquared)} ={" "}
                          <span className="text-foreground">{formatBigInt(keyPair.steps.gLambda)}</span>
                        </p>
                        <p className="text-muted-foreground">
                          L({formatBigInt(keyPair.steps.gLambda)}) = ({formatBigInt(keyPair.steps.gLambda)} - 1) / {formatBigInt(keyPair.publicKey.n)} ={" "}
                          <span className="text-foreground">{formatBigInt(keyPair.steps.lOfGLambda)}</span>
                        </p>
                        <p className="text-muted-foreground">
                          μ = {formatBigInt(keyPair.steps.lOfGLambda)}<sup>-1</sup> mod {formatBigInt(keyPair.publicKey.n)} ={" "}
                          <span className="text-primary font-semibold">{formatBigInt(keyPair.privateKey.mu)}</span>
                        </p>
                      </div>
                    </div>
                  </CollapsibleContent>
                </Collapsible>
              </div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
